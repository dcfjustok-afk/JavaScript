ES6+ 
    ES2015(ES6)
    ES2016(ES7)
    ES2017(ES8)
    ES2018(ES9)
    ES2019(ES10)
    ES2020(ES11)
    ES2021(ES12)

    ES6+ 不仅是语法糖，更是Javascript现代化的基石

1、解构赋值
    数组解构赋值
    对象解构赋值
    函数参数解构赋值

2、模板字符串
    
    const name = 'Tom';
    const msg = `Hello, ${name}!`;
    console.log(msg);

3、箭头函数
    箭头函数是一种更简洁的函数定义方式，它没有自己的this、arguments、super或new.target。
    箭头函数的this指向定义时所在的对象，而不是调用时所在的对象。

****特点总结****

    | 特性             | 普通函数      | 箭头函数      |
    | -------------- | --------- | --------- |
    | `this` 绑定      | 动态（调用时确定） | 静态（定义时确定） |
    | 是否能被 new       | ✅ 可以      | ❌ 不可以     |
    | 是否有 arguments  | ✅ 有       | ❌ 没有      |
    | 原型属性 prototype | ✅ 有       | ❌ 没有      |

4、Class 类
    ✅ 语法基础
    class Person {
        constructor(name) {
            this.name = name;
        }
        sayHello() {
            console.log(`Hello, ${this.name}`);
        }
    }
    class Student extends Person {
        constructor(name, grade) {
            super(name);
            this.grade = grade;
        }
    }
继承的本质
    基于Object.create()实现+super()调用父类构造函数

5、模块化

✅ 基础
// a.js
export const a = 1;
export default function test() {}

// b.js
import test, { a } from './a.js';

✅ 原理理解
    ES Module 是静态加载（编译时确定依赖关系）。
    CommonJS 是动态加载（运行时 require()）。
    浏览器原生支持 ESM 时必须加 type="module"。
🧠 大厂常问：
    Tree Shaking 为什么能用在 ES Module？
    → 因为 import/export 是静态结构，可以在编译阶段分析依赖。

6、Set / Map / WeakSet / WeakMap

    ✅ Set
        const set = new Set([1, 2, 2]);
        console.log([...set]); // [1,2]
    ✅ Map
        const map = new Map();
        map.set('a', 1);
        map.set({x: 1}, 2);
        console.log(map.size); // 2

    ✅ WeakMap / WeakSet
        键必须是对象
        不影响垃圾回收（用于缓存）
🧠 面试题：
WeakMap 为什么不能遍历？
因为它的 key 是弱引用，不可被追踪，防止 GC 泄漏。

7、Proxy / Reflect

✅ Proxy 基础
const obj = {name: 'Tom'};
const proxy = new Proxy(obj, {
  get(target, key) {
    console.log('get', key);
    return target[key];
  },
  set(target, key, value) {
    console.log('set', key, value);
    target[key] = value;
    return true;
  }
});
proxy.name;     // get name
proxy.age = 18; // set age 18

✅ Reflect

是对对象操作的统一接口（如 Reflect.get, Reflect.set）。

与 Proxy 配合使用更安全：

set(target, key, value, receiver) {
  return Reflect.set(target, key, value, receiver);
}


🧠 实战应用：Vue3 响应式核心
Vue3 的响应式系统就是基于 Proxy 拦截对象的 get/set，实现依赖追踪与触发更新。



其他特性：
| 特性                             | 示例                         | 说明                         |
| ------------------------------ | -------------------------- | -------------------------- |
| **Symbol**                     | `const s = Symbol('id')`   | 创建唯一值，避免属性冲突               |
| **Rest参数**                     | `function sum(...args){}`  | 收集剩余参数                     |
| **Spread展开**                   | `[...arr1, ...arr2]`       | 拆解数组或对象                    |
| **async/await**                | `await Promise.resolve(1)` | 异步语法糖                      |
| **可选链**                        | `obj?.a?.b`                | 防止空引用报错                    |
| **空值合并**                       | `x ?? y`                   | 仅当 x 为 null/undefined 时取 y |
| **Object.entries/fromEntries** | `对象 ↔ 数组`                  | 数据转换利器                     |
