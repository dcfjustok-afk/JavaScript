This 概述                   ***重要***
    本质上是 函数运行时绑定的上下文对象（不是词法作用域决定的），他的值取决于****函数调用的方式****，而不是****函数定义的位置****。

换句话说：
    谁调用这个函数，this 就指向谁（大多数情况下）。

1、默认绑定（独立调用）
    当函数独立调用时，this 指向全局对象（浏览器中是 window 对象）。
        严格模式下，this 指向 undefined。
    示例
    function foo() {
        onsole.log(this.a);
    }
    var a = 2;
    foo(); // this → window => 输出 2

    'use strict';
    function bar() {
        console.log(this);
    }
    bar(); // undefined

2.隐式绑定
    当函数作为对象的方法调用时，this 指向该对象。
    示例
    function foo() {
        console.log(this.a);
    }
    var obj = {
        a: 2,
        foo: foo
    };
    obj.foo(); // this → obj => 输出 2

    隐式丢失                ***重要***
        当一个函数被赋值给一个变量，然后独立调用时，this 指向全局对象（非严格模式下）。
    示例：
        function foo() {
            console.log(this.a);
        }
        var obj = {
            a: 2,
            foo: foo
        };
        var bar = obj.foo; // 函数赋值给变量
        bar(); // this → window => 输出 2（非严格模式下）
    因为调用 bar() 时，它是独立调用，隐式绑定丢失。

3.显示绑定
    可以使用 call()、apply() 或 bind() 方法来显式绑定 this。
    示例
    function foo() {
        console.log(this.a);
    }
    var obj = {
        a: 2
    };
    foo.call(obj); // this → obj => 输出 2

🧠 区别
方法	是否立即执行	参数传递方式
call	✅ 是	逐个传参
apply	✅ 是	数组传参
bind	❌ 否（返回新函数）	逐个传参

4. new 绑定  （构造函数调用）
    当函数使用 new 关键字调用时，this 指向新创建的实例对象。

    👉 当使用 new 调用函数时，发生以下步骤：
    1、创建一个新对象；
    2、将这个新对象的 __proto__ 链接到函数的 prototype；
    3、将函数中的 this 绑定到这个新对象；
    4、如果函数没有显式返回对象，则自动返回这个新对象。

    示例
    function Foo(a) {
        this.a = a;
    }
    var bar = new Foo(2);
    console.log(bar.a); // 输出 2

5. 箭头函数 （词法绑定）
    箭头函数没有自己的 this，它 会继承外层作用域的 this。
    示例：
    const obj = {
        a: 10,
        foo: function() {
            const arrow = () => console.log(this.a);
            arrow(); // 10（继承 foo 的 this）
        }
    };
    obj.foo(); // 输出 10

    ⚠️ 注意陷阱：

    const obj = {
        a: 10,
        foo: () => console.log(this.a)
    };
    obj.foo(); // undefined，因为箭头函数 this → window



优先级
    1、new 绑定
    2、显示绑定（call、apply、bind）
    3、隐式绑定
    4、默认绑定