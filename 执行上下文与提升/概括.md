核心概念：

    1、执行上下文（Execution Context）：JavaScript 运行代码时的抽象环境（包含变量环境、作用域链、this 等）。每当执行函数或全局代码或 eval、模块时都会创建一个执行上下文。

    2、执行上下文栈（Call Stack）：正在执行的执行上下文按顺序压入/弹出的栈，当前运行的是栈顶上下文。

    3、变量提升（Hoisting）：标识符（变量/函数）在代码运行之前会被 JavaScript 引擎的创建阶段“登记/初始化”——表现为看起来像被“提到”了顶部。

    4、函数提升：函数声明（function foo(){}）在创建阶段整体提升为可调用的函数对象。

    5、暂时性死区（TDZ, Temporal Dead Zone）：对于 let/const 定义的变量，从块开始到声明处这段时间访问会抛出 ReferenceError——变量存在但不可访问。

1、执行上下文
    组成：
        变量环境（Variable Environment）：存放 var 声明、函数声明、函数参数（以及 let/const 在具体“声明时”的处理）等的绑定。
        词法环境（Lexical Environment）：由 EnvironmentRecord + 指向外部词法环境的引用（即作用域链）。
        this 绑定：根据调用方式不同而不同。

    执行上下文的两个阶段（********最重要**********）
        1.创建阶段
            创建变量 环境与词法环境
            函数声明：整体（函数名+函数体）被创建并绑定到标识符上
            var变量：被声明并初始化为undefined (访问不会出错，只是值为undefined)
            let/const变量：被声明但未初始化，访问时会抛出 ReferenceError。
        2.执行阶段
            按语句逐行执行，完成赋值、函数体执行等操作

2、执行上下文栈 流程：
    1、全局上下文（Global EC）被创建与执行（压栈）

    2、在全局中调用 foo() → 创建 foo 的 执行上下文（压栈）

    3、foo 内又调用 bar() → 创建 bar 的 执行上下文（压栈）

    4、bar 执行完毕 → bar 上下文弹出（返回）

    5、foo 执行完毕 → foo 上下文弹出

    6、全局上下文执行完毕 → 程序结束

栈示意图：
[ Global EC ]  ← created first, at bottom
[ foo EC ]     ← after calling foo
[ bar EC ]     ← after calling bar (currently executing)


函数提升：
    函数声明（function foo(){}）在创建阶段整体提升为可调用的函数对象。 ，可在函数声明之前调用。
    函数表达式（let bar = function(){}）在创建阶段只提升变量名，赋值操作在运行时执行，访问时如果变量未赋值会抛出 ReferenceError。
    箭头函数（let baz = () => {}）在创建阶段也会提升变量名

作用域链与变量查找（与执行上下文相关）：
    每个执行上下文都有一个词法环境，词法环境有对外部环境的引用（即作用域链）。
    变量查找时，从当前执行上下文的词法环境开始，逐级向上查找，直到全局环境。如果在任何环境中都未找到，会抛出 ReferenceError。