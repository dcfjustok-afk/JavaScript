JavaScript 内存管理机制
    JavaScript 是自动内存管理语言，意味着程序员不需要手动释放内存（不像 C/C++），内存的分配和释放主要由 垃圾回收器（Garbage Collector, GC） 自动完成。

1️⃣ 内存分配
JavaScript 中的内存主要分为两类：
    栈内存（Stack）
        存放基本类型（值类型）：Number, String, Boolean, null, undefined, Symbol, BigInt
        分配简单，存储连续，访问快
        生命周期由函数调用栈决定
    堆内存（Heap）
        存放引用类型：Object, Array, Function
        大小不固定，存储复杂数据、
        垃圾回收器负责回收不再被引用的对象

2️⃣垃圾回收机制
JavaScript 内存释放依赖 GC，主要算法有两种：
    标记-清除（Mark-Sweep）
    引用计数（Reference Counting）

    1️⃣标记清除（Mark-Sweep）
        工作原理：
            1.从全局对象开始，遍历所有对象，标记所有被引用的对象
            2.没有被标记的对象就是不可达对象
            3.GC将不可达对象清楚，释放内存
        特点：
            可以解决大部分内存回收问题
            对循环引用也能正确回收
        示例：

        let obj1 = { name: "A" };
        let obj2 = { name: "B" };
        obj1.friend = obj2;
        obj2.friend = obj1;

        obj1 = null; 
        obj2 = null; 
        // 此时 obj1 和 obj2 已不可达，GC 会清理

    2️⃣引用计数（Reference Counting）
        工作原理：
            每个对象维护一个引用计时器，引用 +1 ，解除 引用+1
            引用计数为0的对象可以被回收
        特点：
            简单直接，实时性高
            对循环引用无法正确回收
        示例：
        let a = {};
        let b = {};
        a.ref = b;
        b.ref = a;

        a = null;
        b = null;
        // 引用计数仍为 1，导致内存泄漏

现代浏览器主要使用标记清除（Mark-Sweep）算法，引用计数算法在一些旧版本浏览器中还被使用。

内存泄漏 （Memory Leak）
    内存泄漏指：程序不再使用的对象仍然无法被回收，长期存在会导致页面卡顿或浏览器崩溃。

常见内存泄漏场景：
1、全局变量泄漏
    原因：未声明变量会在自动挂在window全局对象
    function foo() {
        a = 10; // 未使用 let/var/const
    }
    foo();
    console.log(window.a); // a 仍存在，无法回收

2、闭包导致泄露
    原因：闭包会保留外部函数作用域的引用，如果大量数据保存在闭包中未释放，会泄漏
    示例：
    function createClosure() {
        let largeArray = new Array(1000000).fill("*");
        return function() {
            console.log(largeArray[0]);
        }
    }   
    let fn = createClosure();
    // largeArray 无法被回收，直到 fn 被置为 null

3、定时器或回调未清理
    setInterval 或事件监听未移除会导致引用对象一直存在

    let obj = { name: "test" };
    setInterval(() => {
        console.log(obj.name);
    }, 1000);

    // 即使 obj 不再使用，也不会回收

    // 正确移除定时器
    clearInterval(timerId);

4、DOM 引用泄漏
    原因：DOM 元素被 JavaScript 引用，即使从 DOM 中移除，也会存在引用，导致内存泄漏
    示例：
    let div = document.createElement("div");
    document.body.appendChild(div);

    // 移除 DOM 元素
    document.body.removeChild(div);

    // 正确移除引用
    div = null;

5、循环引用
    原因：对象之间相互引用，形成循环，导致引用计数无法为0
    示例：
    let obj1 = {};
    let obj2 = {};
    obj1.ref = obj2;
    obj2.ref = obj1;

    // 正确移除引用
    obj1.ref = null;
    obj2.ref = null;


三、检测内存泄漏
浏览器工具是主要手段：
    1.Chrome DevTools
        Performance 面板：分析性能瓶颈
        Memory 面板：
            Heap Snapshot：查看内存占用对象
            Allocation instrumentation on timeline：记录对象分配
            垃圾回收强制 GC：检测对象是否能释放

    2.观察内存增长
        使用 window.performance.memory 或 DevTools，看是否持续增加且无法回收

    3.Profile 事件监听、定时器
        确认所有事件绑定/定时器在对象销毁时被移除

四、解决内存泄漏的策略

    避免全局变量
        使用 let/const 声明变量
        封装在函数或模块作用域内

    及时清理定时器与事件

        let timer = setInterval(...);
        clearInterval(timer);

        element.addEventListener('click', handler);
        // 移除时
        element.removeEventListener('click', handler);

    合理使用闭包

        尽量避免闭包持有大量数据
        不再需要闭包时将引用置为 null

    解除 DOM 引用

        element.onclick = null;
        element = null;

    工具分析

        使用 DevTools 分析内存快照，发现泄漏对象
        使用第三方工具（如 Chrome Lighthouse）优化性能

五、性能优化相关

    1、减少内存分配

        避免在循环内频繁创建对象

        // 不推荐
        for(let i=0;i<1000;i++){
            let temp = new Array(1000); 
        }
        // 推荐
        let temp = new Array(1000);
        for(let i=0;i<1000;i++){
            // 重复使用 temp
        }

    2、对象池技术

        重复使用对象，避免频繁创建/销毁，减少 GC 压力

    3、懒加载 & 及时释放

        数据不使用时及时置为 null

        对大型数组或缓存数据采取清理策略

    4、避免内存泄漏的循环引用

        特别是 DOM、闭包、对象互相引用