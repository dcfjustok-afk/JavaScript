原型
    javaScript的一种机制
    对象通过他继承属性和方法
    实现对象间的代码共享

    每一个对象都有一个内部属性 [[Prototype]]
    指向其构造函数的原型对象
    
原型链
    由原型连接成的链式结构
    用于属性查找
    实现基于原型的继承

    原型链查找
        当访问一个对象的属性时， 若该对象本身没有该属性， 则会沿着原型链向上查找 （[[Prototype]]） 直到找到该属性或到达原型链的末尾（Object.prototype）
        若找到该属性，则返回该属性的值
        若未找到该属性，则返回 undefined

Prototype / proto
    每个对象都有一个原型属性 __proto__
    指向其构造函数的原型对象
    实现基于原型的继承

    只有函数才有 prototype 属性 ， prototype 是 构造函数创建对象的原型对象
    每个对象都有一个 __proto__ 属性， 指向其构造函数的原型对象
    实现基于原型的继承

Constructor.prototype
    每个构造函数都有一个原型属性 prototype
    指向其原型对象             
    实现基于原型的继承
    所有通过构造函数创建的对象， 其 __proto__ 属性都指向该构造函数的原型对象

Object.getPrototypeOf()         ES6推荐
    用于获取对象的原型对象 Prototype
    与 __proto__ 属性不同， 该方法返回的是一个对象的原型对象， 而不是一个对象的构造函数的原型对象
Object.setPrototypeOf()         ES6推荐
    用于设置对象的原型对象 Prototype
    与 __proto__ 属性不同， 该方法设置的是一个对象的原型对象， 而不是一个对象的构造函数的原型对象
    频繁使用该方法会影响性能

Object.create(prototype, propertiesObject)                 ES6推荐
    用于创建一个新对象
    将新对象的原型对象设置为指定对象
    实现基于原型的继承


instanceof 运算符
    用于判断一个对象是否是另一个对象的实例
    返回值为布尔值
        若对象是构造函数的实例，则返回 true
        否则返回 false
为什么需要 instanceof 运算符
    javaScript类型判断的局限
    typeof 不分辨对象的具体类型
    用于判断一个对象是否是另一个对象的实例
用法
    object instanceof constructor
    object 是要判断的对象
    constructor 是构造函数
检测过程
    从 object 的 __proto__ 属性开始， 沿着原型链向上查找
    若找到 constructor 的原型对象，则返回 true
    否则返回 false

原始类型没有 __proto__ 属性 ，也就是说原始类型没有原型对象

Object.create()  是如何实现基于原型的继承的   （基于原型链实现）
    它创建一个新对象
    将新对象的原型对象设置为指定对象
    返回新对象

Object.create() 存在原因
    1、更纯粹的原型继承
        直接设置新对象的原型
        无需通过构造函数和new 运算符
        更直接表达了基于原型的继承关系
    2、创建无原型对象
        传入 null 作为原型对象
        新对象的 __proto__ 属性为 null
        没有原型链， 不能通过原型链查找属性
        没有继承Object.prototype 的属性和方法
    3、隔离父对象影响
        创建中间空对象作原型
        避免直接修改父对象的原型
        更好的管理属性查找链路
使用方法：
    Object.create(prototype, propertiesObject)
        prototype 是新对象的原型对象
        propertiesObject 是可选参数， 用于定义新对象的属性
