JavaScript 模块化原理
    不仅关系到语法“import/export”，还涉及到打包优化、运行机制、兼容性、性能等底层原理

1、为什么需要模块化
    随着前端项目规模的增大，代码量也会增加，这就导致了代码的维护成本增加。为了提高代码的可维护性，我们需要将代码拆分成多个模块，每个模块负责完成一个特定的功能。
    这就是模块化的由来。

社区先后出现了多种模块化规范，如 CommonJS、AMD、UMD、ESM 等。
直到 ES6 引入了 *****ESM***** 规范，才成为了浏览器与 Node.js 环境下的标准模块化方案。           ****ES Module***

2、CommonJS 规范  Node.js 模块规范
    CommonJS 是 Node.js 环境下的模块化规范，它采用同步加载模块的方式。
    每个模块都是一个独立的文件，模块内部的变量都是私有的，不会污染全局作用域。
    模块之间可以通过 require 函数引入其他模块，通过 module.exports 导出模块的接口。
    📘 基本语法
        // 导出
        module.exports = { a, b }
        exports.c = 123

        // 导入
        const mod = require('./mod')

    📦 特点
        | 特性      | 说明                           |
        | ------- | ---------------------------- |
        | 加载时机    | **运行时加载**（同步）                |
        | 执行方式    | 文件在 `require` 时立即执行一次（只执行一次） |
        | 值拷贝方式   | **值拷贝（缓存）**，多次引入取自缓存         |
        | 环境      | **Node.js** 专属               |
        | this 指向 | `module.exports`             |

        // a.js
        let counter = 0;
        function add() { counter++ }
        module.exports = { counter, add }

        // b.js
        const a = require('./a')
        a.add()
        console.log(a.counter) // 输出 0！不是 1，因为值是拷贝

    ⚙️ 模块加载流程
        1、调用 require(path)；
        2、查找文件、读入、编译执行；
        3、把执行结果缓存到 require.cache；
        4、下次 require 直接从缓存返回。

3、 ES Module （ESM,ES6原生模块）
    ES Module 是 ES6 引入的原生模块规范，它采用异步加载模块的方式。
    每个模块都是一个独立的文件，模块内部的变量都是私有的，不会污染全局作用域。
    模块之间可以通过 import 语句引入其他模块，通过 export 语句导出模块的接口。

    📘 基本语法
        // 导出
        export const a = 1
        export default function() {}

        // 导入
        import { a } from './mod.js'
        import foo from './mod.js'


    📦 特点
        特性	说明
        加载时机	编译时加载（静态）
        执行方式	按依赖关系静态分析，提升执行效率
        值拷贝方式	引用绑定（实时绑定）
        环境	浏览器 & Node.js (v14+ 支持)
        支持 Tree Shaking	✅

    ⚙️ 示例
        // a.js
        export let counter = 0
        export function add() { counter++ }

        // b.js
        import { counter, add } from './a.js'
        add()
        console.log(counter) // 输出 1，因为是引用绑定

    💡 静态特性（与 CommonJS 最大区别）

        ESM 在编译阶段就知道依赖关系（静态依赖），这使得：
        编译器能进行依赖分析；
        可以执行 Tree Shaking；
        import 和 export 必须在顶层作用域。

4、Tree Shaking 原理
    Tree Shaking 是一种静态分析技术，它可以在打包时移除未使用的代码。
        它是一种去除未使用代码的优化技术
    它的原理是基于 ES Module 的静态依赖关系，通过分析模块的导入导出关系，确定哪些代码是被使用的，哪些代码是未使用的。
    未使用的代码会被打包工具（如 Webpack、Rollup 等）移除，从而减小打包体积。

🧩 示例
// utils.js
export function add(a, b) { return a + b }
export function sub(a, b) { return a - b }

// main.js
import { add } from './utils.js'
console.log(add(1, 2))


➡️ 打包后只会保留 add 函数，sub 会被移除。

🚫 注意

Tree Shaking 无法删除：

    有副作用的代码（如全局变量、立即执行函数）；
    动态引入（require(variable)）；
    使用 eval 等不确定的引用。

