javascript 异步编程概括

Promise :
    Promise  异步操作的一种解决方案

    Promise是什么？
        处理异步操作的机制
        代表异步操作的最终完成或失败
        及其对应的结果值或错误信息

    为什么需要Promise？
        改善异步代码的可读性和可维护性
        解决回调地狱问题
        提供统一的错误处理机制
        解决异步操作结果传递问题

    Promise  状态                               ********重要******
        pending  初始状态， 不是成功或失败
        fulfilled  操作成功完成
        rejected  操作失败
    状态特性：
        状态只能从 pending  转换为  fulfilled  或  rejected
        状态一旦改变， 就不可逆转
        成功时，会有一个结果值
        失败时，会有一个错误原因（错误对象）

    Promise 构造函数
        new Promise(excutor)
        executor  执行器函数， 接受两个参数 resolve, reject
        执行器函数会立即执行， 异步操作的结果会在稍后调用 resolve 或 reject
        成功时，调用 resolve 函数， 并传递结果值
        失败时，调用 reject 函数， 并传递错误原因（错误对象）

    Promise  实例方法    参数可选
        then(onFulfilled, onRejected)  
        catch(onRejected)
        finally(onFinally)

    .then()  方法
        处理Promise 成功或者失败的情况
        onFulfilled  成功时调用的函数， 接受 成功结果 value
        onRejected  失败时调用的函数， 接受 失败结果 reason

    .catch()  方法
        .catch(onRejected)  时 .then(null, onRejected) 的语法糖
        专用于处理Promise 失败的情况
        onRejected  失败时调用的函数， 接受 失败结果 reason

    .finally()  方法  不接受任何参数
        无论Promise  状态如何， 都会执行的函数
        用于执行一些清理操作或公共逻辑
        回调函数的返回值  会被忽略
        onFinally  无论成功或失败， 都会调用的函数

    如果Promise reject 了， 但没有提供 onRejected  处理函数， 会导致错误冒泡
        会触发  全局的 unhandledrejection  事件
        Node.js 环境中可能会导致进程奔溃

    确保  所有Promise  都有  适当的  错误处理
        它能捕获链条上  所有  异步操作  中的  错误


async / await 
    async / await 是什么？
        javascript  异步编程的语法糖
        基于Promise  实现， 使异步代码看起来像同步代码
        更简洁、更易读、更易维护

    基于什么？
        基于Promise  实现
        生成器

    核心作用：
        暂停 async 函数的执行
        等待 Promise  决议 （resolve 或 reject）
        返回决议值或抛出错误

    为什么使用 async / await？
        1、代码可读性
            流程更线性
            避免回调地狱问题
            更接近同步代码的编写风格
        2、错误处理
            配合 try / catch  语句， 更方便处理异步操作中的错误
            捕获await Promise  中的错误
            与同步处理错误一致
        3、调试体验
            调用栈更清晰
            易于追踪问题

    async 关键字
        声明异步函数
        总是返回一个 Promise 对象
        非Promise 值会被包装为 Promise.resolve()
    await 关键字
        等待 Promise  决议
        只能在 async 函数中使用
        后面的代码会暂停执行， 等待 Promise  完成
        成功时，返回 Promise  结果值
        失败时，抛出错误

    注意点：
        1、await 只能在 async 函数中使用
        2、await 不会阻塞主线程
            只是暂停 async 函数的执行， 允许其他代码继续运行
            控制权交还给事件循环， 其他任务可以继续执行
            主线程可以继续执行其他任务， 而不需要等待 Promise  完成
        3、错误处理
            未被try ... catch  捕获的错误， 会导致 Promise  状态变为 rejected
            可以使用 .catch()  方法  处理这些错误

    核心总结
        async/await =Promise + Generators 的语法糖
        提高异步代码的可读性和可维护性，简化错误处理
        核心机制是暂停当前的 async 函数执行， 等待 Promise  决议
            成功时，继续执行 async 函数， 返回 Promise  结果值
            失败时，抛出错误， 可以被 try ... catch  捕获
    


如何并发执行多个异步操作？
    1、使用 Promise.all()  方法
        等待所有 Promise  都完成
        返回一个新的 Promise， 其结果是所有 Promise  结果的数组
        只要有一个 Promise  失败， 整个操作就会失败
    2、使用 Promise.race()  方法
        等待第一个 Promise  完成
        返回一个新的 Promise， 其结果是第一个完成的 Promise  的结果
        无论成功或失败， 都返回第一个完成的 Promise  的结果

Promise 静态方法家族

    Promise.all()
    Promise.allSettled()
    Promise.race()
    Promise.any()

    Promise.all()
        等待所有 Promise  都完成
        返回一个新的 Promise， 其结果是所有 Promise  结果的数组
        只要有一个 Promise  失败， 整个操作就会失败

    Promise.allSettled()
        等待所有 Promise  都完成
        返回一个新的 Promise， 其结果是所有 Promise  结果的数组
        无论成功或失败， 都返回一个对象数组， 每个对象包含状态（fulfilled 或 rejected）和值（成功结果）或原因（失败原因）
        
    Promise.race()
        等待第一个 Promise  完成
        返回一个新的 Promise， 其结果是第一个完成的 Promise  的结果
        无论成功或失败， 都返回第一个完成的 Promise  的结果

    Promise.any()
        等待第一个 Promise  成功
        返回一个新的 Promise， 其结果是第一个成功的 Promise  的结果
        只要有一个 Promise  成功， 整个操作就会成功
        如果所有 Promise  都失败， 则返回一个 AggregateError  错误， 包含所有失败原因的数组

