作用域（Scope） 与 闭包（Closure）
    1、词法作用域（Lexical scope / Static scope）：函数的作用域由函数定义时的位置决定，而不是调用时。换句话说，函数在定义时能访问到当时可见的变量。

    2、函数作用域（Function scope）：在 JS 中，function 创建的作用域（var 声明在函数内有效）。

    3、块级作用域（Block scope）：由 {} 定义，let 和 const 有块级作用域；var 没有块级作用域，只受函数作用域约束。

    4、闭包（Closure）：当一个函数可以记住并访问它定义时的词法环境（即使外函数已返回），就产生了闭包。闭包 = 函数 + 创建该函数时的词法环境。 


下面是一个闭包：
function makeCounter() {
  let count = 0;                 // 外部变量，属于词法环境
  return function() {            // 返回的函数形成闭包，保留对 count 的引用
    count++;
    console.log(count);
  };
}

const c = makeCounter();
c(); // 1
c(); // 2

makeCounter 执行后返回的是内部函数。但它仍能访问 count，因为内部函数把 count 的引用保留下来（不是拷贝）。

这是一个有状态函数；count 被保存在闭包的环境中。

闭包导致的内存泄漏的问题

为什么闭包会保留内存？
    闭包通过引用使外层变量仍被活动函数所“可达”。垃圾回收器只回收不再可达（reachable）的对象。只要闭包存在，闭包环境中的变量就是可达的，就不会被回收。
    这不是“垃圾回收器的 bug”，而是闭包的自然行为：闭包用于保存状态，但不恰当使用会导致不必要的内存长期占用。

什么场景会成为内存泄漏？
    创建大型闭包（引用大量外部数据）并长期保留（如注册为全局事件处理器）。
    在 SPA 中不断创建闭包但不移除关联的事件监听或计时器。
    将 DOM 节点保存在闭包中（阻止 DOM 被回收）。

如何避免 / 减少内存问题（面试答要点）

    不在闭包中保存不必要的大对象或大量数组。
    事件监听器、定时器（setInterval）等使用完记得 removeEventListener / clearInterval。
    尽量把大对象的引用切断（赋 null）或限定闭包的生命周期。
    使用弱引用（WeakMap / WeakSet）在合适场景下，避免强引用保持对象的存活。
    代码审查与性能分析（Chrome DevTools 的 Memory heap snapshot）来发现泄漏。

